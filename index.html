<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üèÅ Turniej Wy≈õcigowy - Wiecz√≥r Kawalerski</title>
    <meta name="description" content="Prosty manager turnieju wy≈õcigowego (kwalifikacje ‚Üí grupy ‚Üí faza pucharowa) gotowy na GitHub Pages." />
    <style>
        /* (styles unchanged except small cleanups) */
        *{margin:0;padding:0;box-sizing:border-box}
        :root{--primary:#ff3333;--secondary:#333;--success:#4CAF50;--warning:#ff9800;--danger:#f44336;--group-a:#FFD700;--group-b:#C0C0C0;--group-c:#CD7F32;--group-d:#8B4513}
        body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(135deg,#1e1e1e 0%,#2d2d2d 100%);color:#fff;min-height:100vh;padding:20px}
        .container{max-width:1200px;margin:0 auto}
        h1{text-align:center;font-size:2.2em;margin-bottom:10px;background:linear-gradient(45deg,var(--primary),#ff6666);-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-shadow:2px 2px 4px rgba(0,0,0,.25)}
        .subtitle{text-align:center;font-size:1.05em;color:#aaa;margin-bottom:20px}
        .tabs{display:flex;gap:10px;margin-bottom:20px;flex-wrap:wrap;justify-content:center}
        .tab{padding:10px 18px;background:var(--secondary);border:none;color:white;cursor:pointer;border-radius:30px;font-size:1em;transition:all .2s}
        .tab.active{background:var(--primary);box-shadow:0 5px 20px rgba(255,51,51,.25)}
        .tab-content{display:none}
        .tab-content.active{display:block}
        .card{background:rgba(255,255,255,.04);border-radius:12px;padding:18px;margin-bottom:18px;backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.06)}
        .input-group{display:flex;gap:10px;margin-bottom:12px;flex-wrap:wrap}
        input,select,button{font:inherit}
        input,select{flex:1;padding:10px;border:2px solid rgba(255,255,255,.08);background:rgba(255,255,255,.04);color:white;border-radius:8px;min-width:160px}
        button{padding:10px 18px;background:var(--primary);color:white;border:none;border-radius:8px;cursor:pointer}
        button:disabled{background:#666;cursor:not-allowed}
        .drivers-list{display:grid;gap:10px;margin-top:10px}
        .driver-item{display:flex;justify-content:space-between;align-items:center;padding:12px;background:rgba(255,255,255,.03);border-radius:8px}
        .time-input{width:110px}
        .group-badge{padding:5px 12px;border-radius:20px;font-weight:700;text-transform:uppercase;font-size:.85em;display:inline-block;margin-left:10px}
        .group-A{background:var(--group-a);color:black}.group-B{background:var(--group-b);color:black}.group-C{background:var(--group-c);color:white}.group-D{background:var(--group-d);color:white}
        .bonus-card{padding:14px;margin:10px 0;border-radius:12px;text-align:center;font-weight:700}
        .podium{display:flex;justify-content:center;gap:14px;margin:18px 0;flex-wrap:wrap}
        .podium-item{padding:12px;border-radius:12px;background:rgba(255,255,255,.03);min-width:140px;text-align:center}
        .podium-1{background:linear-gradient(135deg,var(--group-a),#ffcc00);transform:scale(1.05)}
        .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:10px}
        .stat-card{background:linear-gradient(135deg,rgba(255,255,255,.06),rgba(255,255,255,.03));padding:14px;border-radius:12px;text-align:center}
        .stat-value{font-size:1.6em;color:var(--primary);font-weight:700}
        .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.75);z-index:1000;align-items:center;justify-content:center}
        .modal-content{background:rgba(255,255,255,.06);padding:18px;border-radius:12px;max-width:520px;width:92%;text-align:center}
        .card-spinning{animation:spin 900ms linear}
        .podium{display:flex;justify-content:center;gap:14px;margin:18px 0;flex-wrap:wrap}
        .podium-item{padding:12px;border-radius:12px;background:rgba(255,255,255,.03);min-width:140px;text-align:center}
        .podium-1{background:linear-gradient(135deg,gold,#ffcc00);transform:scale(1.05)}
        .podium-2{background:linear-gradient(135deg,silver,#ddd)}
        .podium-3{background:linear-gradient(135deg,#cd7f32,#b87333)}
        @keyframes spin{0%{transform:rotateY(0)}50%{transform:rotateY(180deg)}100%{transform:rotateY(360deg)}}
        @media (max-width:768px){h1{font-size:1.6em}.podium{flex-direction:column;align-items:center}.podium-item{width:100%;max-width:320px}}
        .stopwatch-btn { padding: 6px 10px; margin-left: 5px; }
        .stopwatch-display {
            display: inline-block;
            min-width: 80px;
            text-align: center;
            font-family: monospace;
            font-size: 1.1em;
            font-weight: bold;
            color: var(--primary);
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 4px;
            margin-left: 8px;
        }
        .tournament-bracket {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 40px;
            padding: 30px 0;
        }

        .round-level {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
        }

        .round-level:not(:last-child):after {
            content: '';
            position: absolute;
            bottom: -30px;
            left: 50%;
            width: 2px;
            height: 20px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.3), transparent);
            transform: translateX(-50%);
        }

        .matches-container {
            display: flex;
            justify-content: center;
            gap: 25px;
            flex-wrap: wrap;
            position: relative;
        }

        .match-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            transition: all 0.3s ease;
            min-height: 120px;
        }

        .match-box:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .driver-match {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .driver-match.winner {
            background: rgba(255, 215, 0, 0.15);
            border: 2px solid gold;
            font-weight: bold;
        }

        /* Linie ≈ÇƒÖczƒÖce mecze (dla lepszej wizualizacji) */
        .match-box:before {
            content: '';
            position: absolute;
            top: 50%;
            left: -25px;
            width: 25px;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
        }

        .match-box:after {
            content: '';
            position: absolute;
            top: 50%;
            right: -25px;
            width: 25px;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
        }

        /* Responsywno≈õƒá */
        @media (max-width: 768px) {
            .tournament-bracket {
                gap: 30px;
                padding: 20px 0;
            }
            
            .matches-container {
                gap: 15px;
            }
            
            .match-box {
                width: 280px !important;
                min-width: 280px;
            }
            
            .match-box:before,
            .match-box:after {
                display: none;
            }
            
            .round-level:after {
                display: none;
            }
        }
        .bonus-card-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            margin: 10px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .modal-content .bonus-card-image {
            width: 400px;
            height: 483px;
            margin: 15px auto;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÅ Turniej Wy≈õcigowy</h1>
        <p class="subtitle">Manager turnieju gotowy na GitHub Pages ‚Äî kwalifikacje ‚Üí grupy ‚Üí puchar</p>

        <div class="tabs">
            <button class="tab active" data-tab="setup" onclick="showTab('setup', this)">üìù Uczestnicy</button>
            <button class="tab" data-tab="qualifying" onclick="showTab('qualifying', this)">‚è±Ô∏è Kwalifikacje</button>
            <button class="tab" data-tab="groups" onclick="showTab('groups', this)">üéØ Eliminacje</button>
            <button class="tab" data-tab="knockout" onclick="showTab('knockout', this)">üèÜ Faza Pucharowa</button>
            <button class="tab" data-tab="stats" onclick="showTab('stats', this)">üìä Statystyki</button>
        </div>

        <!-- Setup -->
        <div id="setup" class="tab-content active">
            <div class="card">
                <h2>Dodaj uczestnik√≥w</h2>
                <div class="input-group">
                    <input id="driverName" type="text" placeholder="Imiƒô kierowcy" onkeypress="if(event.key==='Enter') addDriver()" />
                    <button onclick="addDriver()">Dodaj kierowcƒô</button>
                </div>
                <div id="driversList" class="drivers-list"></div>
                <button onclick="startQualifying()" style="margin-top:16px;width:100%">Rozpocznij kwalifikacje ‚Üí</button>
                <div style="display:flex;gap:10px;margin-top:16px;flex-wrap:wrap">
                    <button onclick="exportTournamentToCSV()" style="background:var(--success)">üì§ Eksportuj turniej do CSV</button>
                    <button onclick="importTournamentFromCSV()" style="background:var(--warning);color:black">üì• Importuj turniej z CSV</button>
                </div>
            </div>
        </div>

        <!-- Qualifying -->
        <div id="qualifying" class="tab-content">
            <div class="card">
                <h2>Kwalifikacje - Pomiar czas√≥w</h2>
                <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px">
                    <button onclick="randomizeOrder()">üé≤ Losuj kolejno≈õƒá</button>
                    <button onclick="finishQualifying()">Zako≈Ñcz kwalifikacje i podziel na grupy ‚Üí</button>
                </div>
                <div id="qualifyingList"></div>
            </div>
        </div>

        <!-- Groups -->
        <div id="groups" class="tab-content">
            <div class="card">
                <h2>Eliminacje grupowe</h2>
                <div style="display:flex;gap:8px;justify-content:center;margin-bottom:12px">
                    <button class="group-stage-tab active" onclick="showGroupStage('times', this)">Czasy przejazd√≥w</button>
                    <button class="group-stage-tab" id="bonusTabButton" onclick="showGroupStage('bonuses', this)" disabled>Karty bonusowe</button>
                    <button class="group-stage-tab" onclick="showGroupStage('podium', this)">Podium grup</button>
                </div>
                <div id="groupTimesDisplay" class="group-stage-content"></div>
                <div id="groupBonusesDisplay" class="group-stage-content" style="display:none"></div>
                <div id="groupPodiumDisplay" class="group-stage-content" style="display:none"></div>
                <button onclick="startKnockout()" style="margin-top:12px;width:100%">Przejd≈∫ do fazy pucharowej ‚Üí</button>
            </div>
        </div>

        <!-- Knockout -->
        <div id="knockout" class="tab-content">
            <div class="card">
                <h2>Faza Pucharowa</h2>
                <div id="tournamentBracket"></div>
            </div>
        </div>

        <!-- Stats -->
        <div id="stats" class="tab-content">
            <div class="card">
                <h2>Statystyki turnieju</h2>
                <div id="tournamentStats" class="stats"></div>
                <div id="finalPodium"></div>
                <div id="finalWinner"></div>
            </div>
        </div>

    </div>

    <div id="bonusCardModal" class="modal">
        <div class="modal-content">
            <h2 id="bonusCardTitle">Karta Bonusowa</h2>
            <div id="bonusCardIcon" style="font-size:3.6em;margin:14px 0"></div>
            <p id="bonusCardDescription"></p>
            <div id="bonusCardStats" style="margin:12px 0;padding:10px;background:rgba(0,0,0,.18);border-radius:8px"></div>
            <div style="display:flex;gap:10px;justify-content:center;margin-top:10px">
                <button onclick="closeBonusCardModal()">Zamknij</button>
            </div>
        </div>
    </div>

    <script>
        // Funkcje konwersji czasu
        function secondsToTimeFormat(seconds) {
            if (seconds === null || seconds === undefined) return '--:--.--';
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(2);
            return `${mins.toString().padStart(2, '0')}:${secs.padStart(5, '0')}`;
        }

        function timeFormatToSeconds(timeString) {
            if (!timeString || timeString === '--:--.--') return null;
            const [mins, secs] = timeString.split(':');
            return parseFloat(mins) * 60 + parseFloat(secs);
        }

        function isValidTimeFormat(timeString) {
            return /^\d{1,2}:\d{1,2}\.\d{1,2}$/.test(timeString);
        }
        // Aplikacja - prosty, serializowalny stan
        let appState = {
            drivers: [],
            stage: 'setup',
            groups: { A: [], B: [], C: [], D: [] },
            knockoutBracket: [],
            finalStandings: [],
            bonusCards: [
                { name: 'Zostajesz trƒÖcony imperatorem', effect: 1.2, target: 'average', type: 'negative', icon: 'üëë', image: 'karty/imperator.jpg', description: '+1.2 sek do ≈õredniego czasu' },
                { name: 'Gacie sportowe ‚Äì z przodu ≈º√≥≈Çte z ty≈Çu brƒÖzowe', effect: 1.5, target: 'average', type: 'negative', icon: 'ü©≤', image: 'karty/gacie.png', description: '+1.5 sek do ≈õredniego czasu za przestraszenie pasa≈ºera' },
                { name: 'Dosta≈Çe≈õ playboxa i ƒáwiczysz w NFS', effect: -1, target: 'average', type: 'positive', icon: 'üéÆ', image: 'karty/playbox.jpg', description: '-1 sek do ≈õredniego czasu' },
                { name: 'Odpalasz jointa po za≈ÇƒÖczeniu nitro', effect: -2, target: 'average', type: 'positive', icon: 'üöÄ', image: 'karty/joint.jpg', description: '-2 sek do ≈õredniego czasu' },
                { name: 'Idealna aerodynamika pojazdu po tjuningu', effect: -2, target: 'average', type: 'positive', icon: 'üèéÔ∏è', image: 'karty/tjuning.jpg', description: '-2 sek do ≈õredniego czasu' },
                { name: 'Zatrzymujesz siƒô na koncert ROKONGRELOWCA', effect: 2, target: 'average', type: 'negative', icon: 'üé∏', image: 'karty/koncert.jpg', description: '+2 sek do ≈õredniego czasu' },
                { name: 'Spali≈Ça Ci siƒô ≈ºar√≥wka w aucie i prosisz kolegƒô o pomoc', effect: 1.5, target: 'average', type: 'negative', icon: 'üí°', image: 'karty/zarowka.jpg', description: '+1.5 sek do ≈õredniego czasu' },
                { name: 'Obudzi≈Ç siƒô w Tobie romantyczny kawalir i stajesz po prezerwatywy', effect: 2, target: 'average', type: 'negative', icon: 'üíï', image: 'karty/prezerwatywy.jpg', description: '+2 sek do ≈õredniego czasu' },
                { name: '≈Åysy pyta czy masz problem i zatrzymujesz siƒô mu pom√≥c', effect: 1, target: 'average', type: 'negative', icon: 'üë®‚Äçü¶≤', image: 'karty/lysy.jpg', description: '+1 sek do ≈õredniego czasu' },
                { name: 'Wstƒôpujesz na szybki treninig', effect: 2, target: 'average', type: 'negative', icon: 'üèÉ', image: 'karty/trening.jpg', description: '+2 sek do ≈õredniego czasu' },
                { name: 'Masa wrogiem przyspieszenia (ale za to masz podstawkƒô na piwo)', effect: 1.5, target: 'average', type: 'negative', icon: 'üç∫', image: 'karty/masa.png', description: '+1.5 sek do ≈õredniego czasu' },
                { name: 'Przystajesz w naturze na ≈Çoni aby podziwiaƒá widoki', effect: 1.5, target: 'average', type: 'negative', icon: 'üå≤', image: 'karty/natura.jpg', description: '+1.5 sek do ≈õredniego czasu' },
                { name: 'ZerknƒÖ≈Çe≈õ na bebech', effect: 0.5, target: 'average', type: 'negative', icon: 'üëÄ', image: 'karty/bebech.jpg', description: '+0.5 sek do ≈õredniego czasu' },
                { name: 'PrzysnƒÖ≈Çe≈õ za kierownicƒÖ', effect: 2.5, target: 'average', type: 'negative', icon: 'üò¥', image: 'karty/sen.jpg', description: '+2.5 sek do ≈õredniego czasu' },
                { name: 'Rozstawiasz namiot, ale zajeba≈Ço ≈õledziem', effect: 1, target: 'average', type: 'negative', icon: 'üèïÔ∏è', image: 'karty/namiot.jpg', description: '+1 sek do ≈õredniego czasu' },
                { name: 'Za rogiem stojƒÖ psy i musisz zatrzymaƒá siƒô na jointa', effect: 1.5, target: 'average', type: 'negative', icon: 'üöî', image: 'karty/psy.jpg', description: '+1.5 sek do ≈õredniego czasu' },
                { name: 'Wypi≈Çe≈õ drugie piwo i obudzili siƒô w Tobie okrutne zondze', effect: -1.5, target: 'average', type: 'positive', icon: 'üçª', image: 'karty/piwo.jpg', description: '-1.5 sek do ≈õredniego czasu' },
                { name: 'Wsiadasz za k√≥≈Çko na rauszu', effect: 0.5, target: 'average', type: 'negative', icon: 'ü•¥', image: 'karty/rausz.jpg', description: '+0.5 sek do ≈õredniego czasu' },
                { name: 'Wypad≈Çe≈õ z zakrƒôtu', effect: 1, target: 'average', type: 'negative', icon: 'üåÄ', image: 'karty/zakret.jpg', description: '+1 sek do ≈õredniego czasu' },
                { name: 'UciƒÖ≈Çe≈õ kurze z≈Çote jaje by obni≈ºyƒá masƒô auta', effect: -0.25, target: 'average', type: 'positive', icon: 'ü•ö', image: 'karty/jaje.jpg', description: '-0.25 sek do ≈õredniego czasu' },
                { name: 'Uprowadzi≈Ço Cie UFO ‚Äì ponawiasz przejazd po powrocie na ziemiƒô', effect: 'repeat', type: 'positive', icon: 'üõ∏', image: 'karty/ufo.jpg', description: 'Karta umo≈ºliwia dodatkowy pomiar i podmianƒô gorszego czasu na nowy' },
                { name: 'Dostajesz b≈Çogos≈Çawie≈Ñstwo z Watykanu', effect: -2.137, target: 'average', type: 'positive', icon: '‚õ™', image: 'karty/watykan.jpg', description: '-2.137 sek do ≈õredniego czasu' },
                { name: 'Zajebali Ci silnik', effect: 2, target: 'average', type: 'negative', icon: 'üîß', image: 'karty/silnik.jpg', description: '+2 sek do ≈õredniego czasu' },
                { name: 'Szybki swap', effect: -1.5, target: 'average', type: 'positive', icon: '‚ö°', image: 'karty/swap.jpg', description: '-1.5 sek do ≈õredniego czasu' },
                { name: 'Nawiedza Cie Ada≈õ i musisz mu zmieniƒá majteczki z rzozƒÖ', effect: 1.5, target: 'average', type: 'negative', icon: 'üë∂', image: 'karty/adas.JPG', description: '+1.5 sek do ≈õredniego czasu' },
                { name: 'Zak≈Çadasz kask dla wiƒôkszego bezpiecze≈Ñstwa', effect: -0.5, target: 'average', type: 'positive', icon: 'ü™ñ', image: 'karty/kask.jpg', description: '-0.5 sek do ≈õredniego czasu' },
                { name: 'SPIERDALASZ LAMUSIAKU', effect: 0, target: 'average', type: 'neutral', icon: 'üèÉ‚Äç‚ôÇÔ∏è', image: 'karty/spierdalasz.jpg', description: 'Karta nie wnosi nic do czasu ‚Äì omija Cie kolejka bycia pasa≈ºerem' },
                { name: 'P≈Çu≈ºysz przodem jak jebane Audi', effect: 1.5, target: 'average', type: 'negative', icon: 'üöó', image: 'karty/audi.jpg', description: '+1.5 sek do ≈õredniego czasu' }
            ],
            groupStage: 'times'
        };

        // Dodano obiekt stopera
        let stopwatch = {
            isRunning: false,
            startTime: 0,
            currentDriverId: null,
            currentRun: null,
            currentType: null,
            currentInput: null,
            currentButton: null,
            displayElement: null,
            intervalId: null
        };

        // Dodano funkcje obs≈Çugi stopera
        function toggleStopwatch(driverId, run, type, buttonElement) {
            const input = buttonElement.previousElementSibling;
            
            if (stopwatch.isRunning && stopwatch.currentDriverId === driverId && stopwatch.currentRun === run && stopwatch.currentType === type) {
                stopStopwatch();
            } else {
                if (stopwatch.isRunning) {
                    stopStopwatch();
                    if (stopwatch.currentButton) {
                        stopwatch.currentButton.textContent = '‚è±Ô∏è';
                    }
                }
                
                // Utw√≥rz lub znajd≈∫ element wy≈õwietlacza
                let displayEl = buttonElement.nextElementSibling;
                if (!displayEl || !displayEl.classList.contains('stopwatch-display')) {
                    displayEl = document.createElement('span');
                    displayEl.className = 'stopwatch-display';
                    displayEl.textContent = '00:00.00';
                    buttonElement.parentNode.insertBefore(displayEl, buttonElement.nextSibling);
                }
                
                stopwatch.isRunning = true;
                stopwatch.startTime = Date.now();
                stopwatch.currentDriverId = driverId;
                stopwatch.currentRun = run;
                stopwatch.currentType = type;
                stopwatch.currentInput = input;
                stopwatch.currentButton = buttonElement;
                stopwatch.displayElement = displayEl;
                
                buttonElement.textContent = '‚èπÔ∏è';
                
                // Uruchom aktualizacjƒô wy≈õwietlacza
                stopwatch.intervalId = setInterval(() => {
                    if (stopwatch.isRunning && stopwatch.displayElement) {
                        const elapsed = (Date.now() - stopwatch.startTime) / 1000;
                        stopwatch.displayElement.textContent = secondsToTimeFormat(elapsed);
                    }
                }, 10);
            }
        }

        function stopStopwatch() {
            if (!stopwatch.isRunning) return;
            
            const elapsed = (Date.now() - stopwatch.startTime) / 1000;
            stopwatch.isRunning = false;
            
            // Wyczy≈õƒá interval
            if (stopwatch.intervalId) {
                clearInterval(stopwatch.intervalId);
                stopwatch.intervalId = null;
            }
            
            if (stopwatch.currentInput) {
                stopwatch.currentInput.value = secondsToTimeFormat(elapsed);
                const event = new Event('change');
                stopwatch.currentInput.dispatchEvent(event);
            }
            
            if (stopwatch.currentButton) {
                stopwatch.currentButton.textContent = '‚è±Ô∏è';
            }
            
            // Ukryj lub zresetuj wy≈õwietlacz
            if (stopwatch.displayElement) {
                stopwatch.displayElement.textContent = '00:00.00';
            }
            
            // Resetuj stan stopera
            stopwatch.currentDriverId = null;
            stopwatch.currentRun = null;
            stopwatch.currentType = null;
            stopwatch.currentInput = null;
            stopwatch.currentButton = null;
            stopwatch.displayElement = null;
        }

        // Load / Save
        function loadState(){
            try{
                const raw = localStorage.getItem('racingTournament');
                if(!raw) return;
                const parsed = JSON.parse(raw);
                // Basic compatibility/fallbacks
                appState = Object.assign(appState, parsed);
                // ensure arrays exist
                appState.groups = appState.groups || {A:[],B:[],C:[],D:[]};
                updateAllDisplays();
            }catch(e){console.warn('Failed to load state', e)}
        }
        function saveState(){
            localStorage.setItem('racingTournament', JSON.stringify(appState));
            // subtle visual feedback
            const n = document.getElementById('saveNotification');
            if(n){n.style.display='block';setTimeout(()=>n.style.display='none',1200)}
        }

        // Helpers
        function findDriverById(id){return appState.drivers.find(d=>d.id===id)}

        // UI: Tabs
        function showTab(tabName, btn){
            document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
            if(btn) btn.classList.add('active');
            const el = document.getElementById(tabName);
            if(el) el.classList.add('active');
            updateAllDisplays();
        }

        // Group stage tab
        function showGroupStage(stage, btn){
            appState.groupStage = stage;
            document.querySelectorAll('.group-stage-tab').forEach(t=>t.classList.remove('active'));
            if(btn) btn.classList.add('active');
            document.querySelectorAll('.group-stage-content').forEach(c=>c.style.display='none');
            if(stage==='times') document.getElementById('groupTimesDisplay').style.display='block';
            if(stage==='bonuses') { document.getElementById('groupBonusesDisplay').style.display='block'; updateBonusesDisplay(); }
            if(stage==='podium') { document.getElementById('groupPodiumDisplay').style.display='block'; updatePodiumDisplay(); }
            saveState();
        }

        // Drivers management
        function addDriver(){
            const input = document.getElementById('driverName');
            const name = input.value.trim();
            if(!name) return;
            if(appState.drivers.some(d=>d.name===name)){
                alert('Kierowca o takiej nazwie ju≈º istnieje');
                return;
            }
            const driver = { id: Date.now()+Math.floor(Math.random()*1000), name, qualifyingTime1:null, qualifyingTime2:null, avgTime:null, group:null, groupTime1:null, groupTime2:null, repeatedTime:null, bonusCard:null, finalGroupTime:null, originalAvgTime:null };
            appState.drivers.push(driver);
            input.value='';
            updateDriversList();
            saveState();
        }
        function removeDriver(id){
            if(!confirm('Usu≈Ñ kierowcƒô?')) return;
            appState.drivers = appState.drivers.filter(d=>d.id!==id);
            updateDriversList();
            saveState();
        }
        function updateDriversList(){
            const list = document.getElementById('driversList');
            list.innerHTML = appState.drivers.map(d=>`<div class="driver-item"><span>${escapeHtml(d.name)}</span><div><button onclick="removeDriver(${d.id})" style="background:var(--danger)">Usu≈Ñ</button></div></div>`).join('') || '<div class="card">Brak zawodnik√≥w ‚Äî dodaj minimum 4</div>';
        }

        function getAverageQualiTime(driver){
            if(driver.qualifyingTime1 == null || driver.qualifyingTime2 == null) return null;
            return (driver.qualifyingTime1 + driver.qualifyingTime2) / 2;
        }

        function getMatchTime(driver, round){
            return driver.matchTimes?.[round] ?? null;
        }
        // Qualifying
        function randomizeOrder(){
            appState.drivers = shuffleArray(appState.drivers);
            updateQualifyingList();
            saveState();
        }
        function updateQualifyingList(){
            const list = document.getElementById('qualifyingList');
            if(!appState.drivers.length) { list.innerHTML='<div class="card">Brak zawodnik√≥w</div>'; return }
            list.innerHTML = appState.drivers.map((driver, idx)=>{
                return `<div class="driver-item"><span>${idx+1}. ${escapeHtml(driver.name)}</span><div style="display:flex;gap:8px;align-items:center">
                    <div style="display:flex;align-items:center;gap:4px">
                        <input type="text" pattern="[0-9]{1,2}:[0-9]{1,2}\\.[0-9]{1,2}" class="time-input" placeholder="MM:SS.ss" step="0.01" min="0" value="${driver.qualifyingTime1==null?'':driver.qualifyingTime1}" onchange="updateQualifyingTime(${driver.id},1,this.value)">
                        <button class="stopwatch-btn" onclick="toggleStopwatch(${driver.id}, 1, 'qualifying', this)">‚è±Ô∏è</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:4px">
                        <input type="text" pattern="[0-9]{1,2}:[0-9]{1,2}\\.[0-9]{1,2}" class="time-input" placeholder="MM:SS.ss" step="0.01" min="0" value="${driver.qualifyingTime2==null?'':driver.qualifyingTime2}" onchange="updateQualifyingTime(${driver.id},2,this.value)">
                        <button class="stopwatch-btn" onclick="toggleStopwatch(${driver.id}, 2, 'qualifying', this)">‚è±Ô∏è</button>
                    </div>
                    <span style="min-width:110px;text-align:right">${driver.avgTime?`≈örednia: ${secondsToTimeFormat(driver.avgTime)}s`:''}</span>
                </div></div>`
            }).join('');
        }
        function updateQualifyingTime(id, run, value) {
            const driver = findDriverById(id); if(!driver) return;
            const seconds = timeFormatToSeconds(value);
            if(seconds === null || seconds < 0) return;
            
            if(run===1) driver.qualifyingTime1 = seconds; 
            if(run===2) driver.qualifyingTime2 = seconds;
            
            if(driver.qualifyingTime1 != null && driver.qualifyingTime2 != null) {
                driver.avgTime = (driver.qualifyingTime1 + driver.qualifyingTime2) / 2;
            }
            updateQualifyingList(); saveState();
        }
        function startQualifying(){
            if(appState.drivers.length<4){ alert('Potrzebujesz minimum 4 kierowc√≥w!'); return }
            appState.stage='qualifying'; showTab('qualifying', document.querySelector('[data-tab="qualifying"]'));
            updateQualifyingList();
        }

        // Finish qualifying and split groups
        function finishQualifying(){
            if(appState.drivers.some(d=>d.avgTime==null)){ alert('Nie wszyscy majƒÖ wpisane czasy kwalifikacji'); return }
            const sorted = [...appState.drivers].sort((a,b)=>a.avgTime-b.avgTime);
            const total = sorted.length; const groupSize = Math.ceil(total/4);
            appState.groups.A = sorted.slice(0,groupSize).map(cloneDriverForGroup);
            appState.groups.B = sorted.slice(groupSize,groupSize*2).map(cloneDriverForGroup);
            appState.groups.C = sorted.slice(groupSize*2,groupSize*3).map(cloneDriverForGroup);
            appState.groups.D = sorted.slice(groupSize*3).map(cloneDriverForGroup);
            ['A','B','C','D'].forEach(g=>{ appState.groups[g].forEach(d=>{ d.group=g; const main = appState.drivers.find(x=>x.id===d.id); if(main){ main.group=g } }) });
            appState.stage='groups'; showTab('groups', document.querySelector('[data-tab="groups"]'));
            updateGroupsDisplay(); saveState();
        }
        function cloneDriverForGroup(d){
            // we will reference main driver object by id ‚Äî keep minimal copy
            return { id: d.id, name: d.name, avgTime: d.avgTime, groupTime1:null, groupTime2:null, repeatedTime:null, bonusCard:null, finalGroupTime:null, originalAvgTime:null };
        }

        // Groups display
        function updateGroupsDisplay(){
            const display = document.getElementById('groupTimesDisplay');
            display.innerHTML = ['A','B','C','D'].map(group=>{
                const groupName = {A:'Zapierdalacze',B:'≈öredni (Super)',C:'Niedzielni',D:'Za≈õlimaczeni'}[group];
                const list = (appState.groups[group]||[]).map(driver=>{
                    // sync group times from main driver if present
                    const main = appState.drivers.find(d=>d.id===driver.id);
                    if(main){ driver.groupTime1 = driver.groupTime1 ?? main.groupTime1 ?? null; driver.groupTime2 = driver.groupTime2 ?? main.groupTime2 ?? null }
                    return `<div class="driver-item" style="margin:8px 0"><span>${escapeHtml(driver.name)} (≈ör. kwal: ${driver.avgTime?secondsToTimeFormat(driver.avgTime):'‚Äî'}s)</span><div style="display:flex;gap:8px;align-items:center">
                        <div style="display:flex;align-items:center;gap:4px">
                            <input type="text" pattern="[0-9]{1,2}:[0-9]{1,2}\\.[0-9]{1,2}" class="time-input" placeholder="MM:SS.ss" step="0.01" min="0" value="${driver.groupTime1==null?'':driver.groupTime1}" onchange="updateGroupTime(${driver.id},1,this.value)">
                            <button class="stopwatch-btn" onclick="toggleStopwatch(${driver.id}, 1, 'group', this)">‚è±Ô∏è</button>
                        </div>
                        <div style="display:flex;align-items:center;gap:4px">
                            <input type="text" pattern="[0-9]{1,2}:[0-9]{1,2}\\.[0-9]{1,2}" class="time-input" placeholder="MM:SS.ss" step="0.01" min="0" value="${driver.groupTime2==null?'':driver.groupTime2}" onchange="updateGroupTime(${driver.id},2,this.value)">
                            <button class="stopwatch-btn" onclick="toggleStopwatch(${driver.id}, 2, 'group', this)">‚è±Ô∏è</button>
                        </div>
                    </div></div>`
                }).join('') || '<div class="card">Brak zawodnik√≥w w tej grupie</div>';
                return `<div class="card"><h3>Grupa ${group} - ${groupName} <span class="group-badge group-${group}">${group}</span></h3>${list}</div>`
            }).join('');
            // enable bonuses tab only when all group times for drivers in groups are filled
            const allInGroups = ['A','B','C','D'].flatMap(g=>appState.groups[g]||[]);
            const allTimesEntered = allInGroups.length>0 && allInGroups.every(d=>d.groupTime1!=null && d.groupTime2!=null);
            const bonusBtn = document.getElementById('bonusTabButton'); if(bonusBtn) bonusBtn.disabled = !allTimesEntered;
        }

        // Update group time (stores both on main driver and group copy)
        function updateGroupTime(id, run, value) {
            const seconds = timeFormatToSeconds(value);
            if(seconds === null || seconds < 0) return;
            
            // update main driver
            const main = appState.drivers.find(d=>d.id===id);
            if(!main) return;
            
            if(run===1) main.groupTime1 = seconds; 
            if(run===2) main.groupTime2 = seconds;
            
            if(main.groupTime1 != null && main.groupTime2 != null && !main.originalAvgTime) {
                main.originalAvgTime = (main.groupTime1 + main.groupTime2) / 2;
            }
            
            // update group copy
            ['A','B','C','D'].forEach(g=>{ 
                const copy = (appState.groups[g]||[]).find(x=>x.id===id); 
                if(copy){ 
                    if(run===1) copy.groupTime1 = seconds; 
                    if(run===2) copy.groupTime2 = seconds; 
                } 
            });
            
            updateGroupsDisplay(); saveState();
        }

        // Bonuses display and logic
        function updateBonusesDisplay(){
            const display = document.getElementById('groupBonusesDisplay');
            display.innerHTML = ['A','B','C','D'].map(group=>{
                const groupName = {A:'Zapierdalacze',B:'≈öredni (Super)',C:'Niedzielni',D:'Za≈õlimaczeni'}[group];
                const list = (appState.groups[group]||[]).map(driver=>{
                    const main = appState.drivers.find(d=>d.id===driver.id);
                    const gt1 = main?.groupTime1 ?? driver.groupTime1; const gt2 = main?.groupTime2 ?? driver.groupTime2;
                    const avg = (gt1!=null && gt2!=null) ? ((gt1+gt2)/2).toFixed(2) : '‚Äî';
                    const btnLabel = main?.bonusCard 
                        ? (main.bonusCard.image 
                            ? `<img src="${main.bonusCard.image}" alt="${main.bonusCard.name}" style="width:20px;height:20px;vertical-align:middle;margin-right:5px;">${escapeHtml(main.bonusCard.name)}`
                            : `${escapeHtml(main.bonusCard.name)}`)
                        : 'üé∞ Losuj kartƒô';

                    return `<div class="driver-item" style="margin:8px 0">
                        <div>
                            <div>${escapeHtml(driver.name)}</div>
                            <div style="font-size:.85em;color:#aaa;margin-top:6px">
                                Czasy: ${gt1!=null?secondsToTimeFormat(gt1):'‚Äî'}, ${gt2!=null?secondsToTimeFormat(gt2):'‚Äî'} 
                                | ≈örednia: ${avg}
                            </div>
                        </div>
                        <div style="display:flex;gap:8px;align-items:center">
                            <button onclick="drawBonusCard(${driver.id})" ${main && main.bonusCard ? 'disabled' : ''}>${btnLabel}</button>
                        </div>
                        ${main && main.bonusCard ? `
                            <div style="margin-top:8px;padding:8px;background:rgba(0,0,0,.15);border-radius:8px">
                                <div>Bonus: ${escapeHtml(main.bonusCard.name)}</div>
                                <div>Nowy czas: <strong>${main.finalGroupTime != null ? secondsToTimeFormat(main.finalGroupTime) : '‚Äî'}</strong></div>
                            </div>
                        ` : ''}
                        ${main && main.bonusCard && main.bonusCard.effect==='repeat' && main.repeatedTime==null ? `
                            <div class="repeat-time-input" style="margin-top:8px">
                                <span style="margin-right:8px">Czas powt√≥rzonego przejazdu:</span>
                                <input type="text" pattern="[0-9]{1,2}:[0-9]{1,2}\\.[0-9]{1,2}" class="time-input" step="0.01" min="0" placeholder="MM:SS.ss" onchange="updateRepeatedTime(${driver.id},this.value)">
                            </div>
                        ` : ''}
                    </div>`;
                }).join('') || '<div class="card">Brak zawodnik√≥w w tej grupie</div>';
                return `<div class="card"><h3>Grupa ${group} - ${groupName} <span class="group-badge group-${group}">${group}</span></h3>${list}</div>`
            }).join('');
        }

        function updateRepeatedTime(id, value){
            const v = parseFloat(value); if(isNaN(v)||v<0) return; const main = findDriverById(id); if(!main) return; main.repeatedTime = v; calculateFinalGroupTime(main); updateBonusesDisplay(); saveState();
        }

        function drawBonusCard(id){
            const main = findDriverById(id); if(!main) return; if(main.groupTime1==null || main.groupTime2==null){ alert('Najpierw wpisz oba czasy!'); return }
            const card = appState.bonusCards[Math.floor(Math.random()*appState.bonusCards.length)];
            main.bonusCard = card;
            if(!main.originalAvgTime) main.originalAvgTime = (main.groupTime1+main.groupTime2)/2;
            calculateFinalGroupTime(main);
            showBonusCardAnimation(card, main);
            updateBonusesDisplay(); saveState();
        }

        function showBonusCardAnimation(card, driver){
            const modal = document.getElementById('bonusCardModal');
            document.getElementById('bonusCardTitle').textContent = card.name + ' ' + (card.icon||'');
            const iconEl = document.getElementById('bonusCardIcon');
            if (card.image) {
                iconEl.innerHTML = `<img src="${card.image}" alt="${card.name}" class="bonus-card-image card-spinning">`;
            } else {
                iconEl.textContent = card.icon || '';
                iconEl.classList.add('card-spinning');
            }
            document.getElementById('bonusCardDescription').textContent = `${driver.name} wylosowa≈Ç: ${card.description}`;
            const originalAvg = driver.originalAvgTime ?? ((driver.groupTime1+driver.groupTime2)/2);
            const newAvg = driver.finalGroupTime ?? originalAvg;
            const diff = (newAvg - originalAvg).toFixed(2);
            document.getElementById('bonusCardStats').innerHTML = `<div>≈örednia przed bonusem: <strong>${originalAvg.toFixed(2)}s</strong></div><div>≈örednia po bonusie: <strong>${newAvg.toFixed(2)}s</strong></div><div>R√≥≈ºnica: <strong style="color:${newAvg<originalAvg? '#4CAF50':'#f44336'}">${diff}s</strong></div>`;
            modal.style.display='flex'; setTimeout(()=>iconEl.classList.remove('card-spinning'),900);
        }
        function closeBonusCardModal(){ document.getElementById('bonusCardModal').style.display='none' }

        // Calculate final group time based on card
        function calculateFinalGroupTime(driver){
            if(driver.groupTime1==null || driver.groupTime2==null) return;
            let t1 = driver.groupTime1, t2 = driver.groupTime2;
            let better = Math.min(t1,t2), worse = Math.max(t1,t2);
            let average = (t1 + t2) / 2;
            
            if(driver.bonusCard){ 
                const card = driver.bonusCard; 
                switch(card.effect){
                    case 'repeat':
                        if(driver.repeatedTime!=null){ 
                            better = Math.min(better, driver.repeatedTime); 
                            worse = Math.max(better, driver.repeatedTime); 
                        }
                        driver.finalGroupTime = (better + worse)/2; 
                        break;
                    case 'worst':
                        // set better to current worst time across all drivers
                        const allWorst = appState.drivers.filter(d=>d.groupTime1!=null && d.groupTime2!=null).map(d=>Math.max(d.groupTime1,d.groupTime2));
                        if(allWorst.length) better = Math.max(...allWorst);
                        driver.finalGroupTime = (better + worse)/2; 
                        break;
                    default:
                        if(card.target === 'worse') {
                            worse += card.effect;
                            driver.finalGroupTime = (better + worse)/2;
                        } else if(card.target === 'better') {
                            better += card.effect;
                            driver.finalGroupTime = (better + worse)/2;
                        } else if(card.target === 'better_multiply') {
                            better *= card.effect;
                            driver.finalGroupTime = (better + worse)/2;
                        } else if(card.target === 'worse_multiply') {
                            worse *= card.effect;
                            driver.finalGroupTime = (better + worse)/2;
                        } else if(card.target === 'average') {
                            // Nowa logika - dodaj/odejmij od ≈õredniej
                            driver.finalGroupTime = average + card.effect;
                        } else {
                            // Fallback - traktuj jako ≈õredniƒÖ
                            driver.finalGroupTime = average + card.effect;
                        }
                        break;
                }
            } else { 
                driver.finalGroupTime = average;
            }
        }

        // Knockout: build bracket using group rankings
        function startKnockout(){
            // Ensure all drivers in groups have finalGroupTime
            const allAssigned = ['A','B','C','D'].flatMap(g=>appState.groups[g]||[]);
            if(allAssigned.length===0){ alert('Brak zawodnik√≥w w grupach'); return }
            const anyMissing = allAssigned.some(d=>{
                const main = findDriverById(d.id); return !main || main.finalGroupTime==null;
            });
            if(anyMissing){ alert('Wszyscy zawodnicy muszƒÖ mieƒá wylosowanƒÖ kartƒô i obliczony czas'); return }
            // Sort groups
            ['A','B','C','D'].forEach(g=>{
                appState.groups[g].sort((x,y)=>{
                    const ax = (findDriverById(x.id)?.finalGroupTime) ?? ((x.groupTime1+x.groupTime2)/2);
                    const by = (findDriverById(y.id)?.finalGroupTime) ?? ((y.groupTime1+y.groupTime2)/2);
                    return ax - by;
                });
            });
            // Build first 1vs1 round as requested
            const make = (a,b,name)=>({name,drivers:[a,b]});
            const matches = [];
            if(appState.groups.A[0] && appState.groups.B[0]) matches.push(make(appState.groups.A[0],appState.groups.B[0],'1 miejsce A vs B'));
            if(appState.groups.C[0] && appState.groups.D[0]) matches.push(make(appState.groups.C[0],appState.groups.D[0],'1 miejsce C vs D'));
            if(appState.groups.A[1] && appState.groups.B[1]) matches.push(make(appState.groups.A[1],appState.groups.B[1],'2 miejsce A vs B'));
            if(appState.groups.C[1] && appState.groups.D[1]) matches.push(make(appState.groups.C[1],appState.groups.D[1],'2 miejsce C vs D'));
            if(appState.groups.A[2] && appState.groups.B[2]) matches.push(make(appState.groups.A[2],appState.groups.B[2],'3 miejsce A vs B'));
            if(appState.groups.C[2] && appState.groups.D[2]) matches.push(make(appState.groups.C[2],appState.groups.D[2],'3 miejsce C vs D'));
            appState.knockoutBracket = [{round:'1vs1', matches: matches.map(m=>({ ...m, winner:null }))}];
            appState.knockoutBracket[0].matches.forEach(m=>{
                m.drivers = m.drivers.filter(Boolean);
                if(m.drivers.length === 1){
                    m.winner = m.drivers[0].id;
                }
            });
            showTab('knockout', document.querySelector('[data-tab=\"knockout\"]'));
            updateKnockoutBracket(); 
            saveState();
        }

        function updateKnockoutBracket(){
            const el = document.getElementById('tournamentBracket');
            if(!appState.knockoutBracket || !appState.knockoutBracket.length){ 
                el.innerHTML='<div class="card">Brak drabinki</div>'; 
                return;
            }
            
            el.innerHTML = renderTournamentBracket();
        }

        function renderTournamentBracket() {
            let html = `
                <div class="tournament-bracket" style="display:flex;flex-direction:column;align-items:center;gap:40px;padding:20px">
            `;
            
            // Renderuj ka≈ºdƒÖ rundƒô jako osobny poziom
            appState.knockoutBracket.forEach((round, roundIndex) => {
                html += renderRound(round, roundIndex);
            });
            
            html += `</div>`;
            
            // Dodaj przyciski nawigacyjne
            const lastRound = appState.knockoutBracket[appState.knockoutBracket.length - 1];
            let navigationButtons = '';
            
            if(lastRound.round === '1vs1' && lastRound.matches.filter(m=>m.drivers.length>=1).every(m=>m.winner)) {
                navigationButtons = `<button onclick="generateQuarterFinals()" style="margin-top:30px;width:100%">Przejd≈∫ do ƒáwierƒáfina≈Ç√≥w ‚Üí</button>`;
            } else if(lastRound.round === 'ƒÜwierƒáfina≈Çy' && lastRound.matches.filter(m=>m.drivers.length>=1).every(m=>m.winner)) {
                navigationButtons = `<button onclick="generateSemiFinals()" style="margin-top:30px;width:100%">Przejd≈∫ do p√≥≈Çfina≈Ç√≥w ‚Üí</button>`;
            } else if(lastRound.round === 'P√≥≈Çfina≈Çy' && lastRound.matches.filter(m=>m.drivers.length>=1).every(m=>m.winner)) {
                navigationButtons = `<button onclick="generateFinal()" style="margin-top:30px;width:100%">Przejd≈∫ do fina≈Çu ‚Üí</button>`;
            } else if(lastRound.round === 'FINA≈Å' && lastRound.matches.filter(m=>m.drivers.length>=1).every(m=>m.winner)) {
                navigationButtons = `<button onclick="finishTournament()" style="margin-top:30px;width:100%">Zako≈Ñcz turniej ‚Üí</button>`;
            }
            
            return `<div class="card">${html}${navigationButtons}</div>`;
        }

        function renderRound(round, roundIndex) {
            // Oblicz szeroko≈õƒá mecz√≥w - im p√≥≈∫niejsza runda, tym wƒô≈ºsze mecze
            const matchWidth = Math.max(200, 300 - (roundIndex * 30));
            
            return `
                <div class="round-level" style="display:flex;flex-direction:column;align-items:center;gap:15px">
                    <h3 style="color:var(--primary);margin-bottom:10px">${escapeHtml(round.round)}</h3>
                    <div class="matches-container" style="display:flex;justify-content:center;gap:20px;flex-wrap:wrap">
                        ${round.matches.map((match, matchIndex) => renderMatch(match, round, roundIndex, matchIndex, matchWidth)).join('')}
                    </div>
                </div>
            `;
        }

        function renderMatch(match, round, roundIndex, matchIndex, width) {
            const drivers = match.drivers || [];
            
            return `
                <div class="match-box" style="width:${width}px;background:rgba(255,255,255,0.05);border-radius:10px;padding:15px;border:1px solid rgba(255,255,255,0.1);position:relative">
                    <div style="font-weight:bold;color:var(--primary);margin-bottom:12px;text-align:center;font-size:0.9em">${escapeHtml(match.name)}</div>
                    
                    ${drivers.map(driver => renderDriverInMatch(driver, round, roundIndex, matchIndex)).join('')}
                    
                    ${roundIndex > 0 ? renderConnectorLines() : ''}
                </div>
            `;
        }

        function renderDriverInMatch(driver, round, roundIndex, matchIndex) {
            if (!driver) return '';
            
            const main = findDriverById(driver.id) || driver;
            const val = main.matchTimes?.[round.round] ?? '';
            const isWinner = round.matches[matchIndex].winner === main.id;
            
            return `
                <div class="driver-match ${isWinner ? 'winner' : ''}" 
                    style="display:flex;justify-content:space-between;align-items:center;padding:10px;margin:8px 0;
                            background:${isWinner ? 'rgba(255,215,0,0.15)' : 'rgba(0,0,0,0.2)'};
                            border-radius:6px;border:${isWinner ? '2px solid gold' : '1px solid rgba(255,255,255,0.1)'};
                            transition:all 0.3s ease">
                    <span style="flex:1;font-size:0.9em">${escapeHtml(main.name)}</span>
                    <div style="display:flex;align-items:center;gap:4px">
                        <input type="text" class="time-input" pattern="[0-9]{1,2}:[0-9]{1,2}\\.[0-9]{1,2}" placeholder="MM:SS.ss" step="0.01" min="0" value="${val}" 
                            onchange="updateMatchTime(${roundIndex},${matchIndex},${main.id},'${round.round}',this.value)" 
                            style="width:70px;font-size:0.9em">
                        <button class="stopwatch-btn" onclick="toggleStopwatch(${main.id}, '${round.round}', 'knockout', this)" 
                                style="padding:4px 8px;font-size:0.8em">‚è±Ô∏è</button>
                        ${isWinner ? '<span style="color:gold">üèÜ</span>' : ''}
                    </div>
                </div>
            `;
        }

        function renderConnectorLines() {
            return `
                <div class="connectors" style="position:absolute;top:50%;left:-20px;width:20px;height:2px;background:rgba(255,255,255,0.3)"></div>
                <div class="connectors" style="position:absolute;top:50%;right:-20px;width:20px;height:2px;background:rgba(255,255,255,0.3)"></div>
            `;
        }

        function updateMatchTime(roundIdx, matchIdx, driverId, roundName, value){
            const r = appState.knockoutBracket[roundIdx]; if(!r) return;
            const m = r.matches[matchIdx]; if(!m) return;
            const driver = m.drivers.find(d=>d.id===driverId); if(!driver) return;
            const main = findDriverById(driverId) || driver;
            
            const seconds = timeFormatToSeconds(value);
            if(seconds === null || seconds < 0) return;
            
            if(!main.matchTimes) main.matchTimes = {};
            main.matchTimes[roundName] = seconds;
            
            if(!driver.matchTimes) driver.matchTimes = {};
            driver.matchTimes[roundName] = seconds;
            
            if(m.drivers.every(d=>d.matchTimes && d.matchTimes[roundName] != null)){
                const winner = m.drivers.reduce((a,b)=> a.matchTimes[roundName] < b.matchTimes[roundName] ? a : b);
                m.winner = winner.id;
            }
            
            updateKnockoutBracket();
            saveState();
        }


        function generateQuarterFinals(){
            const last = appState.knockoutBracket.at(-1);
            const winners = last.matches.filter(m=>m.winner).map(m=> m.drivers.find(d=>d.id===m.winner));
            if(winners.length < 2){ alert('Najpierw zako≈Ñcz mecze 1vs1!'); return }
            if(winners.length === 2){
                appState.knockoutBracket.push({
                    round: 'FINA≈Å',
                    matches: [{name:'Fina≈Ç', drivers:[winners[0], winners[1]], winner:null}]
                });
            } else {
                const matches = [];
                for(let i=0;i<winners.length;i+=2){
                    if(winners[i+1]) matches.push({name:`ƒÜwierƒáfina≈Ç ${matches.length+1}`, drivers:[winners[i], winners[i+1]], winner:null});
                    else matches.push({name:`ƒÜwierƒáfina≈Ç ${matches.length+1}`, drivers:[winners[i]], winner:winners[i].id});
                }
                appState.knockoutBracket.push({ round:'ƒÜwierƒáfina≈Çy', matches });
            }
            updateKnockoutBracket(); saveState();
        }
        function generateSemiFinals(){
            const last = appState.knockoutBracket.at(-1);
            const winners = last.matches.filter(m=>m.winner).map(m=> m.drivers.find(d=>d.id===m.winner));
            if(winners.length < 2){ alert('Najpierw zako≈Ñcz ƒáwierƒáfina≈Çy!'); return }
            if(winners.length === 2){
                appState.knockoutBracket.push({
                    round: 'FINA≈Å',
                    matches: [{name:'Fina≈Ç', drivers:[winners[0], winners[1]], winner:null}]
                });
            } else {
                const matches = [];
                for(let i=0;i<winners.length;i+=2){
                    if(winners[i+1]) matches.push({name:`P√≥≈Çfina≈Ç ${matches.length+1}`, drivers:[winners[i], winners[i+1]], winner:null});
                    else matches.push({name:`P√≥≈Çfina≈Ç ${matches.length+1}`, drivers:[winners[i]], winner:winners[i].id});
                }
                appState.knockoutBracket.push({ round:'P√≥≈Çfina≈Çy', matches });
            }
            updateKnockoutBracket(); saveState();
        }
        function generateFinal(){
            const last = appState.knockoutBracket.at(-1);
            const winners = last.matches.filter(m=>m.winner).map(m=> m.drivers.find(d=>d.id===m.winner));
            if(winners.length < 1){ alert('Najpierw zako≈Ñcz p√≥≈Çfina≈Çy!'); return }
            if(winners.length === 1){
                appState.knockoutBracket.push({ round:'FINA≈Å', matches:[{name:'Fina≈Ç', drivers:[winners[0]], winner:winners[0].id}] });
            } else {
                appState.knockoutBracket.push({ round:'FINA≈Å', matches:[{name:'Fina≈Ç', drivers:[winners[0], winners[1]], winner:null}] });
            }
            updateKnockoutBracket(); saveState();
        }

        function finishTournament(){
            const finalRound = appState.knockoutBracket.at(-1);
            const finalMatch = finalRound.matches[0];
            if(!finalMatch.winner){ alert('Najpierw zako≈Ñcz fina≈Ç!'); return; }

            const winner = finalMatch.drivers.find(d=>d.id===finalMatch.winner);
            const loser = finalMatch.drivers.find(d=>d.id!==finalMatch.winner);

            // znajd≈∫ przegranych z p√≥≈Çfina≈Ç√≥w do 3 miejsca
            const semifinalRound = appState.knockoutBracket.find(r=>r.round==='P√≥≈Çfina≈Çy');
            let thirds = [];
            if(semifinalRound){
                const losers = semifinalRound.matches.map(m=>{
                    if(!m.winner) return null;
                    return m.drivers.find(d=>d.id!==m.winner);
                }).filter(Boolean);
                thirds = losers;
            } else {
                // je≈õli nie ma p√≥≈Çfina≈Ç√≥w (np. tylko 4 uczestnik√≥w),
                // to 3 miejsce dla przegranych z poprzedniej rundy
                const prevRound = appState.knockoutBracket.at(-2);
                if(prevRound){
                    const losers = prevRound.matches.map(m=>{
                        if(!m.winner) return null;
                        return m.drivers.find(d=>d.id!==m.winner);
                    }).filter(Boolean);
                    thirds = losers;
                }
            }

            // zapisz do stanu
            appState.finalStandings = [];
            if(winner) appState.finalStandings.push({position:1, driver:winner});
            if(loser) appState.finalStandings.push({position:2, driver:loser});
            thirds.forEach(d => appState.finalStandings.push({position:3, driver:d}));

            saveState();
            updateStats();
            showTab('stats', document.querySelector('[data-tab=\"stats\"]'));
        }

        function updateStats(){
            const statDiv = document.getElementById('tournamentStats');
            if(!statDiv) return;

            // Statystyki og√≥lne ‚Äì liczba zawodnik√≥w, uko≈Ñczone kwalifikacje itp.
            const totalDrivers = appState.drivers.length;
            const qualifiedDrivers = appState.drivers.filter(d=>d.qualifyingTime1!=null && d.qualifyingTime2!=null).length;
            statDiv.innerHTML = `
                <div class="card">
                    <h3>üìã Podsumowanie</h3>
                    <p>≈ÅƒÖczna liczba zawodnik√≥w: <strong>${totalDrivers}</strong></p>
                    <p>Uko≈Ñczone kwalifikacje: <strong>${qualifiedDrivers}</strong></p>
                </div>
            `;

            // üîé Najszybszy i najwolniejszy w kwalifikacjach
            const qualified = appState.drivers.filter(d => d.qualifyingTime1 != null && d.qualifyingTime2 != null);

            if(qualified.length){
                qualified.forEach(d => {
                    d.avgQuali = getAverageQualiTime(d);
                });

                const fastest = qualified.reduce((a,b) => a.avgQuali < b.avgQuali ? a : b);
                const slowest = qualified.reduce((a,b) => a.avgQuali > b.avgQuali ? a : b);

                statDiv.innerHTML += `
                <div class="card">
                    <h3>‚è±Ô∏è Ciekawostki z kwalifikacji</h3>
                    <p><strong>Najszybszy:</strong> ${escapeHtml(fastest.name)} (${fastest.avgQuali.toFixed(2)} s)</p>
                    <p><strong>Najwolniejszy:</strong> ${escapeHtml(slowest.name)} (${slowest.avgQuali.toFixed(2)} s)</p>
                </div>`;
            }

            // üèÜ Podium ko≈Ñcowe
            const fp = document.getElementById('finalPodium');
            if(fp && appState.finalStandings && appState.finalStandings.length){
                const podiumByPos = {1:[],2:[],3:[]};
                appState.finalStandings.forEach(s=> podiumByPos[s.position].push(s.driver));

                fp.innerHTML = `<div class="card"><h2 style="text-align:center">üèÜ KO≈ÉCOWE PODIUM üèÜ</h2>
                <div class="podium">
                ${podiumByPos[1].map(d=>`<div class="podium-item podium-1"><div style="font-size:1.6em">ü•á</div><div style="font-weight:700;font-size:1.05em">${escapeHtml(d.name)}</div><div>Grupa ${escapeHtml(d.group||'‚Äî')}</div></div>`).join('')}
                ${podiumByPos[2].map(d=>`<div class="podium-item podium-2"><div style="font-size:1.6em">ü•à</div><div style="font-weight:700;font-size:1.05em">${escapeHtml(d.name)}</div><div>Grupa ${escapeHtml(d.group||'‚Äî')}</div></div>`).join('')}
                ${podiumByPos[3].map(d=>`<div class="podium-item podium-3"><div style="font-size:1.6em">ü•â</div><div style="font-weight:700;font-size:1.05em">${escapeHtml(d.name)}</div><div>Grupa ${escapeHtml(d.group||'‚Äî')}</div></div>`).join('')}
                </div></div>`;
            }
        }

        // Utility functions
        function shuffleArray(a){ return a.sort(()=>Math.random()-0.5) }
        function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]) }

        // updateAll
        function updateAllDisplays(){ updateDriversList(); updateQualifyingList(); if(appState.stage==='groups'){ if(appState.groupStage==='times') updateGroupsDisplay(); if(appState.groupStage==='bonuses') updateBonusesDisplay(); if(appState.groupStage==='podium') updatePodiumDisplay(); } updateKnockoutBracket(); updateStats(); }

        // small podium display used in groups
        function updatePodiumDisplay(){
            const display = document.getElementById('groupPodiumDisplay');
            display.innerHTML = ['A','B','C','D'].map(group=>{
                const groupName = {A:'Zapierdalacze',B:'≈öredni (Super)',C:'Niedzielni',D:'Za≈õlimaczeni'}[group];
                const drivers = (appState.groups[group]||[]).slice();
                drivers.forEach(d=>{ const main = findDriverById(d.id); if(main){ d.final = main.finalGroupTime ?? ((d.groupTime1!=null && d.groupTime2!=null)? (d.groupTime1+d.groupTime2)/2 : null) } });
                drivers.sort((a,b)=> (a.final??9999) - (b.final??9999));
                const podium = drivers.slice(0,3).map((d,i)=>`<div class="podium-item podium-${i+1}"><div style="font-size:1.2em">${i===0?'ü•á':i===1?'ü•à':'ü•â'}</div><div style="font-weight:700">${escapeHtml(d.name)}</div><div>${d.final? secondsToTimeFormat(d.final):'‚Äî'}</div></div>`).join('');
                const rest = drivers.slice(3).map(d=>`<div class="driver-item" style="margin:6px 0"><span>${escapeHtml(d.name)}</span><span>${d.final? secondsToTimeFormat(d.final):'‚Äî'}</span></div>`).join('');
                return `<div class="card"><h3>Grupa ${group} - ${groupName} <span class="group-badge group-${group}">${group}</span></h3><div class="podium">${podium}</div>${rest?`<div style="margin-top:10px"><h4>Pozostali:</h4>${rest}</div>`:''}</div>`
            }).join('');
        }
        function exportTournamentToCSV() {
            try {
                const data = JSON.stringify(appState);
                const csvContent = `"tournament_data"\n"${data.replace(/"/g, '""')}"`;
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                link.setAttribute('download', `turniej_${timestamp}.csv`);
                
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                alert('Turniej zosta≈Ç wyeksportowany do pliku CSV');
            } catch (e) {
                alert('B≈ÇƒÖd podczas eksportu: ' + e.message);
                console.error('Export error:', e);
            }
        }

        function importTournamentFromCSV() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const csvContent = e.target.result;
                        const lines = csvContent.split('\n');
                        
                        // Sprawd≈∫ czy to prawid≈Çowy format
                        if (lines.length < 2 || !lines[0].includes('tournament_data')) {
                            alert('Nieprawid≈Çowy format pliku CSV');
                            return;
                        }
                        
                        // WyciƒÖgnij dane z drugiej linii i usu≈Ñ cudzys≈Çowy
                        let jsonData = lines[1];
                        if (jsonData.startsWith('"') && jsonData.endsWith('"')) {
                            jsonData = jsonData.slice(1, -1);
                        }
                        // Przywr√≥ƒá podw√≥jne cudzys≈Çowy
                        jsonData = jsonData.replace(/""/g, '"');
                        
                        const importedState = JSON.parse(jsonData);
                        
                        // Sprawd≈∫ czy dane majƒÖ wymagane pola
                        if (!importedState.drivers || !Array.isArray(importedState.drivers)) {
                            alert('Nieprawid≈Çowe dane turnieju w pliku');
                            return;
                        }
                        
                        // Potwierd≈∫ import
                        if (confirm(`Czy chcesz zaimportowaƒá turniej z ${importedState.drivers.length} zawodnikami?\nUWAGA: Obecny turniej zostanie zastƒÖpiony!`)) {
                            // Zachowaj strukturƒô danych
                            appState = Object.assign({
                                drivers: [],
                                stage: 'setup',
                                groups: { A: [], B: [], C: [], D: [] },
                                knockoutBracket: [],
                                finalStandings: [],
                                bonusCards: appState.bonusCards, // Zachowaj aktualne karty
                                groupStage: 'times'
                            }, importedState);
                            
                            // Zapisz stan
                            saveState();
                            
                            // Przejd≈∫ do odpowiedniej zak≈Çadki
                            if (appState.stage === 'qualifying') {
                                showTab('qualifying', document.querySelector('[data-tab="qualifying"]'));
                            } else if (appState.stage === 'groups') {
                                showTab('groups', document.querySelector('[data-tab="groups"]'));
                            } else if (appState.stage === 'knockout') {
                                showTab('knockout', document.querySelector('[data-tab="knockout"]'));
                            } else {
                                showTab('setup', document.querySelector('[data-tab="setup"]'));
                            }
                            
                            // Od≈õwie≈º wszystkie wy≈õwietlacze
                            updateAllDisplays();
                            
                            alert('Turniej zosta≈Ç pomy≈õlnie zaimportowany!');
                        }
                        
                    } catch (e) {
                        alert('B≈ÇƒÖd podczas importu: ' + e.message);
                        console.error('Import error:', e);
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }
        // init
        window.addEventListener('load', ()=>{
            loadState();
            // add reset button
            const container = document.querySelector('.container');
            const resetBtn = document.createElement('button'); resetBtn.textContent='üîÑ Reset turnieju'; resetBtn.style.cssText='background:var(--danger);margin-top:12px'; resetBtn.onclick=()=>{ if(confirm('Czy na pewno?')){ localStorage.removeItem('racingTournament'); location.reload() } };
            container.appendChild(resetBtn);
        });
    </script>
</body>
</html>