<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèÅ Turniej Wy≈õcigowy - Wiecz√≥r Kawalerski</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #ff3333;
            --secondary: #333;
            --success: #4CAF50;
            --warning: #ff9800;
            --danger: #f44336;
            --group-a: #FFD700;
            --group-b: #C0C0C0;
            --group-c: #CD7F32;
            --group-d: #8B4513;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--primary), #ff6666);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            text-align: center;
            font-size: 1.2em;
            color: #aaa;
            margin-bottom: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: var(--secondary);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 30px;
            font-size: 1em;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,51,51,0.3);
        }

        .tab.active {
            background: var(--primary);
            box-shadow: 0 5px 20px rgba(255,51,51,0.5);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        input, select {
            flex: 1;
            padding: 12px;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            color: white;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
            min-width: 200px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255,255,255,0.1);
        }

        button {
            padding: 12px 24px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        button:hover {
            background: #ff4444;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255,51,51,0.4);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .drivers-list {
            display: grid;
            gap: 10px;
            margin-top: 20px;
        }

        .driver-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            border-left: 4px solid var(--primary);
            transition: all 0.3s;
        }

        .driver-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }

        .time-input {
            width: 120px;
        }

        .group-badge {
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9em;
            display: inline-block;
            margin-left: 10px;
        }

        .group-A { background: var(--group-a); color: black; }
        .group-B { background: var(--group-b); color: black; }
        .group-C { background: var(--group-c); color: white; }
        .group-D { background: var(--group-d); color: white; }

        .bonus-card {
            padding: 20px;
            margin: 10px 0;
            border-radius: 15px;
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .bonus-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }

        .bonus-card:hover::before {
            animation: shine 0.5s;
        }

        @keyframes shine {
            to { transform: rotate(45deg) translateX(100%); }
        }

        .bonus-positive {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: 2px solid #45a049;
        }

        .bonus-negative {
            background: linear-gradient(135deg, #f44336, #da190b);
            border: 2px solid #da190b;
        }

        .bracket {
            display: grid;
            gap: 20px;
            margin-top: 30px;
        }

        .match {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
        }

        .match:hover {
            border-color: var(--primary);
            background: rgba(255,255,255,0.1);
        }

        .match-header {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .match-drivers {
            display: grid;
            gap: 10px;
        }

        .match-driver {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .winner {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid var(--success);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: var(--primary);
            margin: 10px 0;
        }

        .stat-label {
            color: #aaa;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        .floating-save {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--success);
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
            display: none;
            animation: slideIn 0.5s;
        }

        @keyframes slideIn {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .trophy {
            font-size: 3em;
            text-align: center;
            margin: 20px 0;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Modal dla kart bonusowych */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.2);
            max-width: 500px;
            width: 90%;
            animation: scaleIn 0.5s;
        }

        @keyframes scaleIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .card-spinning {
            animation: spin 1s ease-in-out;
        }

        @keyframes spin {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
            100% { transform: rotateY(360deg); }
        }

        .podium {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .podium-item {
            text-align: center;
            padding: 20px;
            border-radius: 15px;
            background: rgba(255,255,255,0.05);
            min-width: 150px;
        }

        .podium-1 {
            background: linear-gradient(135deg, var(--group-a), #ffcc00);
            order: 2;
            transform: scale(1.2);
        }

        .podium-2 {
            background: linear-gradient(135deg, var(--group-b), #e0e0e0);
            order: 1;
        }

        .podium-3 {
            background: linear-gradient(135deg, var(--group-c), #b87333);
            order: 3;
        }

        .group-stage-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .group-stage-tab {
            padding: 10px 20px;
            background: var(--secondary);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 20px;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .group-stage-tab.active {
            background: var(--primary);
        }

        @media (max-width: 768px) {
            h1 { font-size: 1.8em; }
            .tab { padding: 10px 16px; font-size: 0.9em; }
            input, select { min-width: 150px; }
            .podium { flex-direction: column; align-items: center; }
            .podium-item { width: 100%; max-width: 250px; }
            .podium-1 { order: 1; transform: scale(1); margin-bottom: 20px; }
            .podium-2 { order: 2; }
            .podium-3 { order: 3; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÅ Turniej Wy≈õcigowy üèéÔ∏è</h1>
        <p class="subtitle">System zarzƒÖdzania zawodami</p>

        <div class="tabs">
            <button class="tab active" onclick="showTab('setup')">üìù Uczestnicy</button>
            <button class="tab" onclick="showTab('qualifying')">‚è±Ô∏è Kwalifikacje</button>
            <button class="tab" onclick="showTab('groups')">üéØ Eliminacje</button>
            <button class="tab" onclick="showTab('knockout')">üèÜ Faza Pucharowa</button>
            <button class="tab" onclick="showTab('stats')">üìä Statystyki</button>
        </div>

        <!-- Zak≈Çadka Uczestnicy -->
        <div id="setup" class="tab-content active">
            <div class="card">
                <h2>Dodaj uczestnik√≥w</h2>
                <div class="input-group">
                    <input type="text" id="driverName" placeholder="Imiƒô kierowcy" onkeypress="if(event.key==='Enter') addDriver()">
                    <button onclick="addDriver()">Dodaj kierowcƒô</button>
                </div>
                <div id="driversList" class="drivers-list"></div>
                <button onclick="startQualifying()" style="margin-top: 20px; width: 100%;">
                    Rozpocznij kwalifikacje ‚Üí
                </button>
            </div>
        </div>

        <!-- Zak≈Çadka Kwalifikacje -->
        <div id="qualifying" class="tab-content">
            <div class="card">
                <h2>Kwalifikacje - Pomiar czas√≥w</h2>
                <button onclick="randomizeOrder()" style="margin-bottom: 20px;">üé≤ Losuj kolejno≈õƒá</button>
                <div id="qualifyingList"></div>
                <button onclick="finishQualifying()" style="margin-top: 20px; width: 100%;">
                    Zako≈Ñcz kwalifikacje i podziel na grupy ‚Üí
                </button>
            </div>
        </div>

        <!-- Zak≈Çadka Eliminacje Grupowe -->
        <div id="groups" class="tab-content">
            <div class="card">
                <h2>Eliminacje grupowe</h2>
                
                <div class="group-stage-tabs">
                    <button class="group-stage-tab active" onclick="showGroupStage('times')">Czasy przejazd√≥w</button>
                    <button class="group-stage-tab" onclick="showGroupStage('bonuses')" id="bonusTabButton">Karty bonusowe</button>
                    <button class="group-stage-tab" onclick="showGroupStage('podium')">Podium grup</button>
                </div>
                
                <div id="groupTimesDisplay" class="group-stage-content"></div>
                <div id="groupBonusesDisplay" class="group-stage-content" style="display: none;"></div>
                <div id="groupPodiumDisplay" class="group-stage-content" style="display: none;"></div>
                
                <button onclick="startKnockout()" style="margin-top: 20px; width: 100%;">
                    Przejd≈∫ do fazy pucharowej ‚Üí
                </button>
            </div>
        </div>

        <!-- Zak≈Çadka Faza Pucharowa -->
        <div id="knockout" class="tab-content">
            <div class="card">
                <h2>Faza Pucharowa</h2>
                <div id="tournamentBracket"></div>
            </div>
        </div>

        <!-- Zak≈Çadka Statystyki -->
        <div id="stats" class="tab-content">
            <div class="card">
                <h2>Statystyki turnieju</h2>
                <div id="tournamentStats" class="stats"></div>
                <div id="finalWinner"></div>
            </div>
        </div>
    </div>

    <div id="saveNotification" class="floating-save">
        ‚úÖ Zapisano automatycznie
    </div>

    <!-- Modal dla kart bonusowych -->
    <div id="bonusCardModal" class="modal">
        <div class="modal-content">
            <h2 id="bonusCardTitle">Karta Bonusowa</h2>
            <div id="bonusCardIcon" style="font-size: 4em; margin: 20px 0;"></div>
            <p id="bonusCardDescription"></p>
            <button onclick="closeBonusCardModal()" style="margin-top: 20px;">Zamknij</button>
        </div>
    </div>

    <script>
        // Stan aplikacji
        let appState = {
            drivers: [],
            stage: 'setup',
            groups: { A: [], B: [], C: [], D: [] },
            knockoutBracket: [],
            bonusCards: [
                { name: 'Turbo üöÄ', effect: -1.5, target: 'worse', type: 'positive', icon: 'üöÄ', description: 'Odejmij 1.5s od gorszego przejazdu' },
                { name: 'Nitro üí®', effect: -2, target: 'worse', type: 'positive', icon: 'üí®', description: 'Odejmij 2s od gorszego przejazdu' },
                { name: 'Czysta linia üéØ', effect: 'repeat', type: 'positive', icon: 'üéØ', description: 'Powt√≥rz przejazd i wybierz lepszy wynik' },
                { name: 'Lepsze opony üõû', effect: 0.98, target: 'better_multiply', type: 'positive', icon: 'üõû', description: 'Czas z lepszego przejazdu x0.98' },
                { name: 'Lepsze paliwo ‚õΩ', effect: -1, target: 'worse', type: 'positive', icon: '‚õΩ', description: 'Odejmij 1s od gorszego przejazdu' },
                { name: 'Perfekcyjny start üèÅ', effect: -2.137, target: 'worse', type: 'positive', icon: 'üèÅ', description: 'Odejmij 2.137s od gorszego przejazdu' },
                { name: 'Z≈Çapa≈Çe≈õ kapcia üëü', effect: 2, target: 'better', type: 'negative', icon: 'üëü', description: 'Dodaj 2s do lepszego przejazdu' },
                { name: '≈öliska nawierzchnia üåßÔ∏è', effect: 1.5, target: 'better', type: 'negative', icon: 'üåßÔ∏è', description: 'Dodaj 1.5s do lepszego przejazdu' },
                { name: 'Pechowy zakrƒôt üîÑ', effect: 2.5, target: 'worse', type: 'negative', icon: 'üîÑ', description: 'Dodaj 2.5s do gorszego przejazdu' },
                { name: 'Zmƒôczenie üò¥', effect: 1.69, target: 'better', type: 'negative', icon: 'üò¥', description: 'Dodaj 1.69s do lepszego przejazdu' },
                { name: 'Pechowy driver üíÄ', effect: 'worst', type: 'negative', icon: 'üíÄ', description: 'Lepszy czas zamieniony na najgorszy czas w tabeli' },
                { name: 'Pit stop üîß', effect: 1.02, target: 'worse_multiply', type: 'negative', icon: 'üîß', description: 'Czas gorszego przejazdu x1.02' }
            ],
            groupStage: 'times'
        };

        // ≈Åadowanie stanu z localStorage
        function loadState() {
            const saved = localStorage.getItem('racingTournament');
            if (saved) {
                appState = JSON.parse(saved);
                updateAllDisplays();
            }
        }

        // Zapisywanie stanu
        function saveState() {
            localStorage.setItem('racingTournament', JSON.stringify(appState));
            showSaveNotification();
        }

        function showSaveNotification() {
            const notification = document.getElementById('saveNotification');
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }

        // Zmiana zak≈Çadek
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            updateAllDisplays();
        }

        // Zmiana etapu w zak≈Çadce grupowej
        function showGroupStage(stage) {
            appState.groupStage = stage;
            document.querySelectorAll('.group-stage-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.group-stage-content').forEach(content => content.style.display = 'none');
            
            event.target.classList.add('active');
            
            if (stage === 'times') {
                document.getElementById('groupTimesDisplay').style.display = 'block';
            } else if (stage === 'bonuses') {
                document.getElementById('groupBonusesDisplay').style.display = 'block';
                updateBonusesDisplay();
            } else if (stage === 'podium') {
                document.getElementById('groupPodiumDisplay').style.display = 'block';
                updatePodiumDisplay();
            }
            
            saveState();
        }

        // Dodawanie kierowcy
        function addDriver() {
            const input = document.getElementById('driverName');
            const name = input.value.trim();
            
            if (name && !appState.drivers.find(d => d.name === name)) {
                appState.drivers.push({
                    id: Date.now(),
                    name: name,
                    qualifyingTime1: null,
                    qualifyingTime2: null,
                    avgTime: null,
                    group: null,
                    groupTime1: null,
                    groupTime2: null,
                    bonusCard: null,
                    finalGroupTime: null
                });
                input.value = '';
                updateDriversList();
                saveState();
            }
        }

        // Usuwanie kierowcy
        function removeDriver(id) {
            appState.drivers = appState.drivers.filter(d => d.id !== id);
            updateDriversList();
            saveState();
        }

        // Aktualizacja listy kierowc√≥w
        function updateDriversList() {
            const list = document.getElementById('driversList');
            list.innerHTML = appState.drivers.map(driver => `
                <div class="driver-item">
                    <span>${driver.name}</span>
                    <button onclick="removeDriver(${driver.id})" style="background: var(--danger);">
                        Usu≈Ñ
                    </button>
                </div>
            `).join('');
        }

        // Rozpoczƒôcie kwalifikacji
        function startQualifying() {
            if (appState.drivers.length < 4) {
                alert('Potrzebujesz minimum 4 kierowc√≥w!');
                return;
            }
            appState.stage = 'qualifying';
            showTab('qualifying');
            updateQualifyingList();
        }

        // Losowanie kolejno≈õci
        function randomizeOrder() {
            appState.drivers = appState.drivers.sort(() => Math.random() - 0.5);
            updateQualifyingList();
            saveState();
        }

        // Aktualizacja listy kwalifikacyjnej
        function updateQualifyingList() {
            const list = document.getElementById('qualifyingList');
            list.innerHTML = appState.drivers.map((driver, index) => `
                <div class="driver-item">
                    <span>${index + 1}. ${driver.name}</span>
                    <div style="display: flex; gap: 10px;">
                        <input type="number" 
                               class="time-input" 
                               placeholder="Czas 1" 
                               step="0.01"
                               min="0"
                               value="${driver.qualifyingTime1 || ''}"
                               onchange="updateQualifyingTime(${driver.id}, 1, this.value)">
                        <input type="number" 
                               class="time-input" 
                               placeholder="Czas 2" 
                               step="0.01"
                               min="0"
                               value="${driver.qualifyingTime2 || ''}"
                               onchange="updateQualifyingTime(${driver.id}, 2, this.value)">
                        <span style="min-width: 100px; text-align: right;">
                            ${driver.avgTime ? `≈örednia: ${driver.avgTime.toFixed(2)}s` : ''}
                        </span>
                    </div>
                </div>
            `).join('');
        }

        // Aktualizacja czasu kwalifikacyjnego
        function updateQualifyingTime(id, run, time) {
            const driver = appState.drivers.find(d => d.id === id);
            const timeValue = parseFloat(time);
            if (isNaN(timeValue) || timeValue < 0) return;
            
            if (run === 1) driver.qualifyingTime1 = timeValue;
            if (run === 2) driver.qualifyingTime2 = timeValue;
            
            if (driver.qualifyingTime1 && driver.qualifyingTime2) {
                driver.avgTime = (driver.qualifyingTime1 + driver.qualifyingTime2) / 2;
            }
            
            updateQualifyingList();
            saveState();
        }

        // Zako≈Ñczenie kwalifikacji i podzia≈Ç na grupy
        function finishQualifying() {
            const driversWithTimes = appState.drivers.filter(d => d.avgTime);
            if (driversWithTimes.length !== appState.drivers.length) {
                alert('Nie wszyscy kierowcy majƒÖ wpisane czasy!');
                return;
            }

            // Sortowanie wed≈Çug czas√≥w
            driversWithTimes.sort((a, b) => a.avgTime - b.avgTime);
            
            // Podzia≈Ç na grupy
            const groupSize = Math.ceil(driversWithTimes.length / 4);
            appState.groups.A = driversWithTimes.slice(0, groupSize);
            appState.groups.B = driversWithTimes.slice(groupSize, groupSize * 2);
            appState.groups.C = driversWithTimes.slice(groupSize * 2, groupSize * 3);
            appState.groups.D = driversWithTimes.slice(groupSize * 3);
            
            // Przypisanie grup
            Object.keys(appState.groups).forEach(group => {
                appState.groups[group].forEach(driver => {
                    driver.group = group;
                });
            });
            
            appState.stage = 'groups';
            showTab('groups');
            updateGroupsDisplay();
            saveState();
        }

        // Wy≈õwietlanie grup - czƒô≈õƒá z czasami
        function updateGroupsDisplay() {
            const display = document.getElementById('groupTimesDisplay');
            display.innerHTML = Object.keys(appState.groups).map(group => {
                const groupName = {
                    'A': 'Zapierdalacze',
                    'B': '≈öredni (Super)',
                    'C': 'Niedzielni kierowcy',
                    'D': 'Za≈õlimaczeni'
                }[group];
                
                return `
                    <div class="card">
                        <h3>Grupa ${group} - ${groupName} <span class="group-badge group-${group}">${group}</span></h3>
                        ${appState.groups[group].map(driver => `
                            <div class="driver-item" style="margin: 10px 0;">
                                <span>${driver.name} (≈ör. kwal: ${driver.avgTime.toFixed(2)}s)</span>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="number" 
                                           class="time-input" 
                                           placeholder="Czas 1" 
                                           step="0.01"
                                           min="0"
                                           value="${driver.groupTime1 || ''}"
                                           onchange="updateGroupTime(${driver.id}, 1, this.value)">
                                    <input type="number" 
                                           class="time-input" 
                                           placeholder="Czas 2" 
                                           step="0.01"
                                           min="0"
                                           value="${driver.groupTime2 || ''}"
                                           onchange="updateGroupTime(${driver.id}, 2, this.value)">
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }).join('');
            
            // Sprawd≈∫ czy wszystkie czasy sƒÖ wpisane i aktywuj zak≈Çadkƒô z bonusami
            const allTimesEntered = appState.drivers.every(d => d.groupTime1 && d.groupTime2);
            document.getElementById('bonusTabButton').disabled = !allTimesEntered;
        }

        // Wy≈õwietlanie bonus√≥w
        function updateBonusesDisplay() {
            const display = document.getElementById('groupBonusesDisplay');
            display.innerHTML = Object.keys(appState.groups).map(group => {
                const groupName = {
                    'A': 'Zapierdalacze',
                    'B': '≈öredni (Super)',
                    'C': 'Niedzielni kierowcy',
                    'D': 'Za≈õlimaczeni'
                }[group];
                
                return `
                    <div class="card">
                        <h3>Grupa ${group} - ${groupName} <span class="group-badge group-${group}">${group}</span></h3>
                        ${appState.groups[group].map(driver => `
                            <div class="driver-item" style="margin: 10px 0;">
                                <span>${driver.name}</span>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <button onclick="drawBonusCard(${driver.id})" 
                                            style="background: ${driver.bonusCard ? '#666' : 'var(--warning)'};"
                                            ${driver.bonusCard ? 'disabled' : ''}>
                                        ${driver.bonusCard ? driver.bonusCard.name : 'üé∞ Losuj kartƒô'}
                                    </button>
                                </div>
                                ${driver.finalGroupTime ? `
                                    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                                        Czas po bonusie: <strong>${driver.finalGroupTime.toFixed(2)}s</strong>
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            }).join('');
        }

        // Wy≈õwietlanie podium grup
        function updatePodiumDisplay() {
            const display = document.getElementById('groupPodiumDisplay');
            display.innerHTML = Object.keys(appState.groups).map(group => {
                const groupName = {
                    'A': 'Zapierdalacze',
                    'B': '≈öredni (Super)',
                    'C': 'Niedzielni kierowcy',
                    'D': 'Za≈õlimaczeni'
                }[group];
                
                // Sortuj kierowc√≥w w grupie wed≈Çug finalGroupTime lub avgTime
                const sortedDrivers = [...appState.groups[group]].sort((a, b) => {
                    const timeA = a.finalGroupTime || a.avgTime;
                    const timeB = b.finalGroupTime || b.avgTime;
                    return timeA - timeB;
                });
                
                return `
                    <div class="card">
                        <h3>Grupa ${group} - ${groupName} <span class="group-badge group-${group}">${group}</span></h3>
                        <div class="podium">
                            ${sortedDrivers.slice(0, 3).map((driver, index) => `
                                <div class="podium-item podium-${index + 1}">
                                    <div style="font-size: 2em;">${index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â'}</div>
                                    <div style="font-weight: bold; font-size: 1.2em;">${driver.name}</div>
                                    <div>${(driver.finalGroupTime || driver.avgTime).toFixed(2)}s</div>
                                </div>
                            `).join('')}
                        </div>
                        ${sortedDrivers.length > 3 ? `
                            <div style="margin-top: 20px;">
                                <h4>Pozostali zawodnicy:</h4>
                                ${sortedDrivers.slice(3).map(driver => `
                                    <div class="driver-item" style="margin: 5px 0;">
                                        <span>${driver.name}</span>
                                        <span>${(driver.finalGroupTime || driver.avgTime).toFixed(2)}s</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // Aktualizacja czasu grupowego
        function updateGroupTime(id, run, time) {
            const driver = appState.drivers.find(d => d.id === id);
            const timeValue = parseFloat(time);
            if (isNaN(timeValue) || timeValue < 0) return;
            
            if (run === 1) driver.groupTime1 = timeValue;
            if (run === 2) driver.groupTime2 = timeValue;
            
            // Sprawd≈∫ czy wszystkie czasy sƒÖ wpisane i aktywuj zak≈Çadkƒô z bonusami
            const allTimesEntered = appState.drivers.every(d => d.groupTime1 && d.groupTime2);
            document.getElementById('bonusTabButton').disabled = !allTimesEntered;
            
            updateGroupsDisplay();
            saveState();
        }

        // Losowanie karty bonusowej
        function drawBonusCard(id) {
            const driver = appState.drivers.find(d => d.id === id);
            if (!driver.groupTime1 || !driver.groupTime2) {
                alert('Najpierw wpisz oba czasy!');
                return;
            }
            
            const randomCard = appState.bonusCards[Math.floor(Math.random() * appState.bonusCards.length)];
            
            // Animacja losowania karty
            showBonusCardAnimation(randomCard, driver);
            
            driver.bonusCard = randomCard;
            
            calculateFinalGroupTime(driver);
            
            updateBonusesDisplay();
            saveState();
        }

        // Pokazanie animacji karty bonusowej
        function showBonusCardAnimation(card, driver) {
            const modal = document.getElementById('bonusCardModal');
            const title = document.getElementById('bonusCardTitle');
            const icon = document.getElementById('bonusCardIcon');
            const description = document.getElementById('bonusCardDescription');
            
            title.textContent = card.name;
            icon.textContent = card.icon;
            icon.className = 'card-spinning';
            description.textContent = `${driver.name} wylosowa≈Ç: ${card.description}`;
            
            modal.style.display = 'flex';
            
            // Zatrzymaj animacjƒô po chwili
            setTimeout(() => {
                icon.classList.remove('card-spinning');
            }, 1000);
        }

        // Zamkniƒôcie modalu z kartƒÖ bonusowƒÖ
        function closeBonusCardModal() {
            document.getElementById('bonusCardModal').style.display = 'none';
        }

        // Obliczanie ko≈Ñcowego czasu po bonusie
        function calculateFinalGroupTime(driver) {
            if (!driver.groupTime1 || !driver.groupTime2) return;
            
            let time1 = driver.groupTime1;
            let time2 = driver.groupTime2;
            let betterTime = Math.min(time1, time2);
            let worseTime = Math.max(time1, time2);
            
            if (driver.bonusCard) {
                const card = driver.bonusCard;
                
                switch(card.effect) {
                    case 'repeat':
                        // Mo≈ºliwo≈õƒá powt√≥rzenia - dla uproszczenia zak≈Çadamy lepszy wynik
                        driver.finalGroupTime = betterTime;
                        break;
                    case 'worst':
                        // Pechowy driver - najgorszy czas w tabeli
                        const allTimes = appState.drivers
                            .filter(d => d.groupTime1 && d.groupTime2)
                            .map(d => Math.max(d.groupTime1, d.groupTime2));
                        driver.finalGroupTime = Math.max(...allTimes, worseTime);
                        break;
                    default:
                        if (card.target === 'worse') {
                            worseTime += card.effect;
                        } else if (card.target === 'better') {
                            betterTime += card.effect;
                        } else if (card.target === 'better_multiply') {
                            betterTime *= card.effect;
                        } else if (card.target === 'worse_multiply') {
                            worseTime *= card.effect;
                        }
                        driver.finalGroupTime = (betterTime + worseTime) / 2;
                }
            } else {
                driver.finalGroupTime = (time1 + time2) / 2;
            }
        }

        // Rozpoczƒôcie fazy pucharowej
        function startKnockout() {
            // Sprawd≈∫ czy wszyscy majƒÖ bonusy
            const allHaveBonuses = appState.drivers.every(d => d.bonusCard !== null);
            if (!allHaveBonuses) {
                alert('Nie wszyscy kierowcy wylosowali jeszcze karty bonusowe!');
                return;
            }
            
            // Sortowanie w grupach wed≈Çug czas√≥w
            Object.keys(appState.groups).forEach(group => {
                appState.groups[group].sort((a, b) => 
                    (a.finalGroupTime || a.avgTime) - (b.finalGroupTime || b.avgTime)
                );
            });
            
            // Tworzenie drabinki 1vs1
            appState.knockoutBracket = [
                {
                    round: '1vs1',
                    matches: [
                        { name: 'Walka o 1 miejsce (A vs B)', drivers: [appState.groups.A[0], appState.groups.B[0]] },
                        { name: 'Walka o 1 miejsce (C vs D)', drivers: [appState.groups.C[0], appState.groups.D[0]] },
                        { name: 'Walka o 2 miejsce (A vs B)', drivers: [appState.groups.A[1], appState.groups.B[1]] },
                        { name: 'Walka o 2 miejsce (C vs D)', drivers: [appState.groups.C[1], appState.groups.D[1]] },
                        { name: 'Walka o 3 miejsce (A vs B)', drivers: [appState.groups.A[2], appState.groups.B[2]] },
                        { name: 'Walka o 3 miejsce (C vs D)', drivers: [appState.groups.C[2], appState.groups.D[2]] }
                    ].filter(m => m.drivers[0] && m.drivers[1])
                }
            ];
            
            appState.stage = 'knockout';
            showTab('knockout');
            updateKnockoutBracket();
            saveState();
        }

        // Aktualizacja drabinki pucharowej
        function updateKnockoutBracket() {
            const bracket = document.getElementById('tournamentBracket');
            bracket.innerHTML = appState.knockoutBracket.map(round => `
                <div class="card">
                    <h3>${round.round}</h3>
                    <div class="bracket">
                        ${round.matches.map((match, idx) => `
                            <div class="match">
                                <div class="match-header">${match.name}</div>
                                <div class="match-drivers">
                                    ${match.drivers.map(driver => driver ? `
                                        <div class="match-driver ${match.winner === driver.id ? 'winner' : ''}">
                                            <span>${driver.name}</span>
                                            <div>
                                                <input type="number" 
                                                       class="time-input" 
                                                       placeholder="Czas wy≈õcigu" 
                                                       step="0.01"
                                                       min="0"
                                                       onchange="updateMatchTime(${appState.knockoutBracket.length - 1}, ${idx}, ${driver.id}, this.value)">
                                                ${match.winner === driver.id ? 'üèÜ' : ''}
                                            </div>
                                        </div>
                                    ` : '<div class="match-driver">TBD</div>').join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    ${round.round === '1vs1' ? `
                        <button onclick="generateQuarterFinals()" style="margin-top: 20px; width: 100%;">
                            Generuj ƒáwierƒáfina≈Çy ‚Üí
                        </button>
                    ` : ''}
                    ${round.round === 'ƒÜwierƒáfina≈Çy' ? `
                        <button onclick="generateSemiFinals()" style="margin-top: 20px; width: 100%;">
                            Generuj p√≥≈Çfina≈Çy ‚Üí
                        </button>
                    ` : ''}
                    ${round.round === 'P√≥≈Çfina≈Çy' ? `
                        <button onclick="generateFinal()" style="margin-top: 20px; width: 100%;">
                            Generuj fina≈Ç ‚Üí
                        </button>
                    ` : ''}
                </div>
            `).join('');
        }

        // Aktualizacja czasu meczu
        function updateMatchTime(roundIdx, matchIdx, driverId, time) {
            const currentRound = appState.knockoutBracket[roundIdx];
            const match = currentRound.matches[matchIdx];
            const driver = match.drivers.find(d => d.id === driverId);
            
            if (driver) {
                const timeValue = parseFloat(time);
                if (isNaN(timeValue) || timeValue < 0) return;
                
                driver.matchTime = timeValue;
                
                // Sprawd≈∫ czy oba czasy sƒÖ wpisane
                if (match.drivers.every(d => d.matchTime)) {
                    // Okre≈õl zwyciƒôzcƒô
                    const winner = match.drivers.reduce((a, b) => 
                        a.matchTime < b.matchTime ? a : b
                    );
                    match.winner = winner.id;
                }
            }
            
            updateKnockoutBracket();
            saveState();
        }

        // Generowanie ƒáwierƒáfina≈Ç√≥w
        function generateQuarterFinals() {
            const lastRound = appState.knockoutBracket[appState.knockoutBracket.length - 1];
            const winners = lastRound.matches
                .filter(m => m.winner)
                .map(m => m.drivers.find(d => d.id === m.winner));
            
            if (winners.length < 4) {
                alert('Najpierw zako≈Ñcz wszystkie mecze 1vs1!');
                return;
            }
            
            appState.knockoutBracket.push({
                round: 'ƒÜwierƒáfina≈Çy',
                matches: [
                    { name: 'ƒÜwierƒáfina≈Ç 1', drivers: [winners[0], winners[3]] },
                    { name: 'ƒÜwierƒáfina≈Ç 2', drivers: [winners[1], winners[2]] }
                ].filter(m => m.drivers[0] && m.drivers[1])
            });
            
            updateKnockoutBracket();
            saveState();
        }

        // Generowanie p√≥≈Çfina≈Ç√≥w
        function generateSemiFinals() {
            const lastRound = appState.knockoutBracket[appState.knockoutBracket.length - 1];
            const winners = lastRound.matches
                .filter(m => m.winner)
                .map(m => m.drivers.find(d => d.id === m.winner));
            
            if (winners.length < 2) {
                alert('Najpierw zako≈Ñcz wszystkie ƒáwierƒáfina≈Çy!');
                return;
            }
            
            appState.knockoutBracket.push({
                round: 'P√≥≈Çfina≈Çy',
                matches: [
                    { name: 'P√≥≈Çfina≈Ç', drivers: winners }
                ]
            });
            
            updateKnockoutBracket();
            saveState();
        }

        // Generowanie fina≈Çu
        function generateFinal() {
            const lastRound = appState.knockoutBracket[appState.knockoutBracket.length - 1];
            const winner = lastRound.matches[0].winner;
            
            if (!winner) {
                alert('Najpierw zako≈Ñcz p√≥≈Çfina≈Ç!');
                return;
            }
            
            const finalDriver = lastRound.matches[0].drivers.find(d => d.id === winner);
            
            appState.knockoutBracket.push({
                round: 'FINA≈Å',
                matches: [
                    { 
                        name: 'üèÜ ZWYCIƒòZCA TURNIEJU üèÜ', 
                        drivers: [finalDriver],
                        winner: finalDriver.id
                    }
                ]
            });
            
            showTab('stats');
            updateStats();
            saveState();
        }

        // Aktualizacja statystyk
        function updateStats() {
            const stats = document.getElementById('tournamentStats');
            const allTimes = appState.drivers
                .filter(d => d.avgTime)
                .map(d => d.avgTime);
            
            const fastestQualifying = Math.min(...allTimes);
            const slowestQualifying = Math.max(...allTimes);
            const avgQualifying = allTimes.reduce((a, b) => a + b, 0) / allTimes.length;
            
            const finalRound = appState.knockoutBracket.find(r => r.round === 'FINA≈Å');
            const champion = finalRound ? finalRound.matches[0].drivers[0] : null;
            
            stats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Liczba kierowc√≥w</div>
                    <div class="stat-value">${appState.drivers.length}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Najszybszy czas kwalifikacji</div>
                    <div class="stat-value">${fastestQualifying.toFixed(2)}s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Najwolniejszy czas kwalifikacji</div>
                    <div class="stat-value">${slowestQualifying.toFixed(2)}s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">≈öredni czas kwalifikacji</div>
                    <div class="stat-value">${avgQualifying.toFixed(2)}s</div>
                </div>
            `;
            
            if (champion) {
                document.getElementById('finalWinner').innerHTML = `
                    <div class="card" style="text-align: center; background: linear-gradient(135deg, var(--group-a), var(--warning));">
                        <div class="trophy">üèÜ</div>
                        <h1 style="color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
                            ZWYCIƒòZCA TURNIEJU
                        </h1>
                        <h2 style="font-size: 2.5em; margin: 20px 0; color: white;">
                            ${champion.name}
                        </h2>
                        <p style="font-size: 1.2em; color: white;">
                            Grupa ${champion.group} | Czas kwalifikacji: ${champion.avgTime.toFixed(2)}s
                        </p>
                    </div>
                `;
            }
        }

        // Aktualizacja wszystkich wy≈õwietlaczy
        function updateAllDisplays() {
            updateDriversList();
            updateQualifyingList();
            
            if (appState.stage === 'groups') {
                if (appState.groupStage === 'times') {
                    updateGroupsDisplay();
                } else if (appState.groupStage === 'bonuses') {
                    updateBonusesDisplay();
                } else if (appState.groupStage === 'podium') {
                    updatePodiumDisplay();
                }
            }
            
            updateKnockoutBracket();
            updateStats();
        }

        // Reset aplikacji
        function resetTournament() {
            if (confirm('Czy na pewno chcesz zresetowaƒá ca≈Çy turniej? Wszystkie dane zostanƒÖ utracone!')) {
                localStorage.removeItem('racingTournament');
                location.reload();
            }
        }

        // Inicjalizacja
        window.onload = function() {
            loadState();
            
            // Dodaj przycisk resetu
            const container = document.querySelector('.container');
            const resetBtn = document.createElement('button');
            resetBtn.innerHTML = 'üîÑ Reset turnieju';
            resetBtn.style.cssText = 'background: var(--danger); margin-top: 30px;';
            resetBtn.onclick = resetTournament;
            container.appendChild(resetBtn);
        };
    </script>
</body>
</html>